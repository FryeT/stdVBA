{
  "version": 3,
  "sources": ["main.ts"],
  "sourcesContent": ["/**\r\n     'Some comment\r\n     '@param MethodPointer as LongPtr - Pointer to the method to call\r\n     '@param iRetType as VbVarType - The return type of the method\r\n     '@param vParamTypes as Array<Variant<VbVarType>> - The types of the parameters\r\n     #If VBA7 Then\r\n       Public Function CreateFromPointer(ByVal MethodPointer As LongPtr, Optional ByVal iRetType As VbVarType = 0, Optional vParamTypes = Null) As stdCallback\r\n     #Else\r\n       Public Function CreateFromPointer(ByVal MethodPointer As Long, Optional ByVal iRetType As VbVarType = 0, Optional vParamTypes = Null) As stdCallback\r\n     #End If\r\n* TODO: Add public enums\r\n* TODO: Add public types?\r\n* TODO: Add public constants\r\n* TODO: Add `ByRef` and `ByVal` to param types, needs adding to IParam, already in `IDataParam` as `referenceType` \r\n* TODO: Add line numbers for methods. This could be utilised to add links to source code.\r\n*/\r\n\r\n/**\r\n * Take input stubs like:\r\n *\r\n *   'Creates an `stdAcc` object from an `X` and `Y` point location on the screen.\r\n *   '@constructor\r\n *   '@protected\r\n *   '@deprecated\r\n *   '@param x as Long - X Coordinate\r\n *   '@param y as Long - Y Coordinate\r\n *   '@returns stdAcc - Object at the specified point\r\n *   '@example ```vb\r\n'acc.CreateFromPoint(100, 200).DoDefaultAction\r\n'```\r\n *   '@example ```\r\n *   '  acc.CreateFromPoint(0, 0).FindFirst(stdLambda.Create(\"$1.name=\"\"hello\"\" and $1.class=\"\"world\"\"\"))\r\n *   '```\r\n *   Public Function CreateFromPoint(ByVal x As Long, ByVal y As Long) As stdAcc\r\n *\r\n *   'Search the IAccessible tree for elements which match a certain criteria. Return the first element found.\r\n *   '@param ByVal query as stdICallable<(stdAcc,depth)=>EAccFindResult> - Callback returning\r\n *   '  EAccFindResult options:\r\n *   '    EAccFindResult.NoMatchFound/0/False             - Not found, countinue walking\r\n *   '    EAccFindResult.MatchFound/1/-1/True             - Found, return this element\r\n *   '    EAccFindResult.NoMatchCancelSearch/2            - Not found, cancel search\r\n *   '    EAccFindResult.NoMatchSkipDescendents/3,else    - Not found, don't search descendents\r\n *   '    EAccFindResult.MatchFoundSearchDescendents/4    - Same as EAccFindResult.MatchFound\r\n *   '@param {EAccFindType=1} - The type of search, 0 for Breadth First Search (BFS) and 1 for Depth First Search (DFS).\r\n *   ' To understand the difference between BFS and DFS take this tree:\r\n *   '        A\r\n *   '       / \\\r\n *   '      B   C\r\n *   '     /   / \\\r\n *   '    D   E   F\r\n *   ' A BFS will walk this tree in the following order: A, B, C, D, E, F\r\n *   ' A DFS will walk this tree in a different order:   A, C, F, E, B, D\r\n *   '@examples\r\n *   ' ```\r\n *   ' 'Find where name is \"hello\" and class is \"world\":\r\n *   ' el.FindFirst(stdLambda.Create(\"$1.name=\"\"hello\"\" and $1.class=\"\"world\"\"\"))\r\n *   ' 'Find first element named \"hello\" at depth > 4:\r\n *   ' el.FindFirst(stdLambda.Create(\"$1.name = \"\"hello\"\" AND $2 > 4\"))\r\n *   ' ```\r\n *   Public Function FindFirst(ByVal query As stdICallable, optional byval searchType as EAccFindType=EAccFindType.DepthFirst) As stdAcc\r\n *\r\n * And dump these to docs array, with structure:\r\n * [\r\n *   {\r\n *     name: string //name in VBattributes code\r\n *     methods: [\r\n *       {\r\n *         name: string //name in code\r\n *         type: \"sub\"|\"function\"|\"property\"\r\n *         params: [\r\n *           {\r\n *             name: string //name in code\r\n *             type: string //type in code or type in comment if present\r\n *             description: string //description in comment,\r\n *             optional: boolean //true if param is optional\r\n *             defaultValue: string //default value if param is optional\r\n *             paramArray: boolean //true if param is paramarray, false otherwise\r\n *           },\r\n *           ...\r\n *         ],\r\n *         returns: {\r\n *           type: string //return type in code or type in comment if present\r\n *           description: string //description in comment\r\n *         },\r\n *         description: string //description in comment\r\n *         access: \"ReadOnly\"|\"WriteOnly\"|\"ReadWrite\" //access in code\r\n *         protected: boolean //true if protected as per comment\r\n *         deprecated: boolean //true if deprecated as per comment\r\n *         constructor: boolean //true if constructor as per comment\r\n *         examples: string[] //examples in comment as markdown\r\n *       },\r\n *       ...\r\n *     ]\r\n *   }\r\n * ]\r\n */\r\n\r\nfunction log(\r\n  message: string,\r\n  type: \"info\" | \"warn\" | \"error\" | \"success\" = \"info\"\r\n) {\r\n  switch (type) {\r\n    case \"info\":\r\n      console.log(`\\x1b[36m\u2139\uFE0F  Info: ${message}\\x1b[0m`);\r\n      break;\r\n    case \"warn\":\r\n      console.log(`\\x1b[33;1m\u26A0\uFE0F  Warn: ${message}\\x1b[0m`);\r\n      break;\r\n    case \"error\":\r\n      console.log(`\\x1b[31;1m\u274C  Error: ${message}\\x1b[0m`);\r\n      break;\r\n    case \"success\":\r\n      console.log(`\\x1b[32;1m\u2705  Success: ${message}\\x1b[0m`);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Groups an array of objects by a key getter\r\n * @param list - The array to group\r\n * @param keyGetter - The key getter to use to group the array\r\n * @returns - The grouped array\r\n */\r\nfunction groupBy<T>(\r\n  list: T[],\r\n  keyGetter: (item: T) => string\r\n): { [key: string]: T[] } {\r\n  const map = Object.create(null) as { [key: string]: T[] };\r\n  if (!list) return map;\r\n\r\n  list.forEach((item) => {\r\n    const key = keyGetter(item);\r\n    const collection = map[key];\r\n    if (!collection) {\r\n      map[key] = [item];\r\n    } else {\r\n      collection.push(item);\r\n    }\r\n  });\r\n\r\n  return map;\r\n}\r\n\r\ntype IDocs = (IModule | IClass)[];\r\ntype IModule = {\r\n  name: string;\r\n  fileName: string;\r\n  description: string;\r\n  remarks: string[];\r\n  examples: string[];\r\n  methods: IMethod[];\r\n  properties: IProperty[];\r\n  devNotes: string[];\r\n  todos: string[];\r\n  requires: string[];\r\n};\r\ntype IClass = IModule & {\r\n  implements: string[];\r\n  constructors: IConstructor[];\r\n  events: IEvent[];\r\n};\r\ntype IMethod = {\r\n  name: string;\r\n  description: string;\r\n  remarks: string[];\r\n  examples: string[];\r\n  params: IParam[];\r\n  returns: IReturn;\r\n  devNotes: string[];\r\n  todos: string[];\r\n  throws: IThrows[];\r\n  requires: string[];\r\n\r\n  isStatic: boolean;\r\n  isProtected: boolean;\r\n  isDefaultMember: boolean;\r\n  deprecation: {\r\n    status: boolean;\r\n    message: string;\r\n  };\r\n};\r\n\r\ntype IProperty = IMethod & {\r\n  access: \"ReadOnly\" | \"WriteOnly\" | \"ReadWrite\";\r\n};\r\ntype IConstructor = IMethod;\r\ntype IEvent = {\r\n  name: string;\r\n  description: string;\r\n  remarks: string[];\r\n  examples: string[];\r\n  params: IParam[];\r\n  devNotes: string[];\r\n  todos: string[];\r\n};\r\ntype IParam = {\r\n  name: string;\r\n  type: string;\r\n  description: string;\r\n  optional: boolean;\r\n  defaultValue: string | null;\r\n  paramArray: boolean;\r\n  referenceType: \"ByRef\" | \"ByVal\";\r\n};\r\ntype IReturn = {\r\n  type: string;\r\n  description: string;\r\n};\r\ntype IThrows = {\r\n  errNumber: number;\r\n  errText: string;\r\n};\r\n\r\ntype ITagTypes =\r\n  | \"constructor\"\r\n  | \"protected\"\r\n  | \"deprecated\"\r\n  | \"param\"\r\n  | \"returns\"\r\n  | \"example\"\r\n  | \"description\"\r\n  | \"remark\"\r\n  | \"devNote\"\r\n  | \"TODO\"\r\n  | \"throws\"\r\n  | \"requires\"\r\n  | \"static\";\r\n\r\ntype ITagLine = {\r\n  tag: ITagTypes;\r\n  content: string;\r\n};\r\n\r\ntype ICommentStore = ICommentRecord[];\r\ntype ICommentRecord =\r\n  | IDataConstructor\r\n  | IDataProtected\r\n  | IDataDeprecated\r\n  | IDataParam\r\n  | IDataReturn\r\n  | IDataExample\r\n  | IDataDescription\r\n  | IDataRemark\r\n  | IDataDevNote\r\n  | IDataTODO\r\n  | IDataThrows\r\n  | IDataRequires\r\n  | IDataStatic;\r\n\r\ntype IDataConstructor = {\r\n  tag: \"constructor\";\r\n};\r\ntype IDataProtected = {\r\n  tag: \"protected\";\r\n};\r\ntype IDataDeprecated = {\r\n  tag: \"deprecated\";\r\n  data: \"\" | string; //E.G. \"Use `stdLambda.Create()` instead.\"\r\n};\r\ntype IDataParam = {\r\n  tag: \"param\";\r\n  data: {\r\n    name: string; //from comment\r\n    type: string; //from comment or param data\r\n    description: string; //from comment\r\n    referenceType?: string; //from param data\r\n    paramArray?: boolean; //from param data\r\n    optional?: boolean; //from param data\r\n    defaultValue?: string | null; //from param data\r\n  };\r\n};\r\ntype IDataReturn = {\r\n  tag: \"returns\";\r\n  data: {\r\n    type: string; //from comment or param data\r\n    description: string;\r\n  };\r\n};\r\ntype IDataExample = {\r\n  tag: \"example\";\r\n  data: string;\r\n};\r\ntype IDataDescription = {\r\n  tag: \"description\";\r\n  data: string;\r\n};\r\ntype IDataRemark = {\r\n  tag: \"remark\";\r\n  data: string;\r\n};\r\ntype IDataDevNote = {\r\n  tag: \"devNote\";\r\n  data: string;\r\n};\r\ntype IDataTODO = {\r\n  tag: \"TODO\";\r\n  data: string;\r\n};\r\ntype IDataThrows = {\r\n  tag: \"throws\";\r\n  data: {\r\n    errNumber: number;\r\n    errText: string;\r\n  };\r\n};\r\ntype IDataRequires = {\r\n  tag: \"requires\";\r\n  data: string;\r\n};\r\ntype IDataStatic = {\r\n  tag: \"static\";\r\n};\r\n\r\n//Assertions to ensure all tags declared in ITagTypes are implemented\r\ntype TagFromRecord = ICommentRecord extends { tag: infer T } ? T : never;\r\ntype TagsAreEqual = [ITagTypes] extends [TagFromRecord]\r\n  ? [TagFromRecord] extends [ITagTypes]\r\n    ? true\r\n    : false\r\n  : false;\r\ntype _AssertTagMatch<T extends true> = T;\r\n\r\n// \u274C Error here if not all tags in ITagTypes are implemented in ICommentRecord\r\ntype __triggerTagMismatchError = _AssertTagMatch<TagsAreEqual>;\r\n\r\n/**\r\n * Parses a comment block and extracts lines starting with tagged annotations.\r\n *\r\n * A tagged line must begin with `'@tagName` followed by its content.\r\n * Lines without a leading `'@` are grouped as part of the previous tag's content.\r\n *\r\n * Example input:\r\n * ```\r\n * '@test hello\r\n * '@test world\r\n * '@this is\r\n * 'fine\r\n * '@thing\r\n * ```\r\n * Produces:\r\n * ```ts\r\n * [\r\n *   { tag: \"test\", content: \"hello\" },\r\n *   { tag: \"test\", content: \"world\" },\r\n *   { tag: \"this\", content: \"is\\r\\n'fine\" },\r\n *   { tag: \"thing\", content: \"\" }\r\n * ]\r\n * ```\r\n * @param comment - The full comment string to parse.\r\n * @returns An array of tag-content pairs extracted from the comment.\r\n */\r\nfunction parseToTagLines(comment: string): ITagLine[] {\r\n  const groupByRx = /'@(?<type>\\w+)(?<content>.*\\s+(?:'[^@][^\\n]*\\s+)*)?/g;\r\n  const matches = [...comment.matchAll(groupByRx)];\r\n  return matches.map((match) => ({\r\n    tag: match.groups?.type as ITagTypes,\r\n    content: match.groups?.content?.replace(/^'/gm, \"\") ?? \"\",\r\n  }));\r\n}\r\n\r\n/**\r\n * Transforms a comment into a comment store object\r\n * @param comment - The comment to parse\r\n * @returns - The comment store object\r\n */\r\nfunction parseComment(comment: string): ICommentStore {\r\n  //If undefined or empty, return empty array\r\n  if (!comment) return [];\r\n\r\n  //inject @description into 1st line of comment for easier parsing\r\n  comment = comment.replace(/^'/g, \"'@description \");\r\n  const tagLines = parseToTagLines(comment);\r\n\r\n  //Extracts and groups comments under their flag/tag type e.g. \"@example hello\\r\\n'world\"\r\n  const regexTags = {\r\n    description: /^\\s*(?<description>[\\s\\S]+)/i,\r\n    param:\r\n      /^\\s*(?<name>\\w+)\\s*(?:as\\s+(?<type>[^-]+))?(?:\\s*-\\s*(?<description>[\\s\\S]+))?$/i, //regex needs work\r\n    returns: /^\\s*(?<type>[^-\\r\\n]+)?(?:\\s*-\\s*(?<description>[\\s\\S]+))?$/i,\r\n    constructor: /(?:constructor)?/g, //overwrites native constructor\r\n    throws: /(?<errNumber>\\d+)\\s*,\\s*(?<errText>.+)/i,\r\n  };\r\n\r\n  //Parse comment into comment store\r\n  const commentStore: ICommentStore = [];\r\n  for (let tagLine of tagLines) {\r\n    let tag = tagLine.tag;\r\n    let groups;\r\n    if (!!regexTags[tag]) {\r\n      groups = regexTags[tag].exec(tagLine.content)?.groups;\r\n    }\r\n\r\n    //If comment not valid ignore\r\n    switch (tag) {\r\n      case \"description\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"param\":\r\n        if (!!groups?.name)\r\n          commentStore.push({\r\n            tag,\r\n            data: {\r\n              name: groups.name.trim(),\r\n              type: groups?.type?.trim(),\r\n              description: groups?.description.trim(),\r\n            },\r\n          });\r\n        break;\r\n      case \"returns\":\r\n        commentStore.push({\r\n          tag,\r\n          data: {\r\n            type: groups?.type?.trim(),\r\n            description: groups?.description.trim(),\r\n          },\r\n        });\r\n        break;\r\n      case \"example\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"remark\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"devNote\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"constructor\":\r\n        commentStore.push({ tag });\r\n        break;\r\n      case \"protected\":\r\n        commentStore.push({ tag });\r\n        break;\r\n      case \"deprecated\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"TODO\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"throws\":\r\n        commentStore.push({\r\n          tag,\r\n          data: {\r\n            errNumber: Number(groups?.errNumber),\r\n            errText: groups?.errText,\r\n          },\r\n        });\r\n        break;\r\n      case \"requires\":\r\n        commentStore.push({ tag, data: tagLine.content.trim() });\r\n        break;\r\n      case \"static\":\r\n        commentStore.push({ tag });\r\n        break;\r\n      default:\r\n        log(`Unknown tag \"${tag}\"`, \"warn\");\r\n    }\r\n  }\r\n\r\n  return commentStore;\r\n}\r\n\r\n/**\r\n * Given a VBA param string and a param data object initialised from the comment, obtains additional information from the param data and injects it into the param data object.\r\n * @param params - The param string to parse.\r\n * @param dataParams - The params data objects to populate.\r\n * @returns - The populated param data object.\r\n */\r\nfunction parseParams(params: string, dataParams: IDataParam[]): IDataParam[] {\r\n  //Group params by name\r\n  const paramData = groupBy<IDataParam>(dataParams, (d) =>\r\n    d.data.name.toLowerCase()\r\n  );\r\n\r\n  const paramRegex =\r\n    /(?<optional>optional\\s+)?(?:(?<referenceType>byval|byref)\\s+)?(?:(?<paramarray>paramarray)\\s+)?(?<name>\\w+)(?<isArray>\\(\\))?(?:\\s+as\\s+(?<type>[^, )]+))?(?:\\s*=\\s*(?<defaultValue>[^,\\)]+))?/gi;\r\n  const paramMatches = [...params.matchAll(paramRegex)];\r\n\r\n  const paramStore: IDataParam[] = [];\r\n  for (let paramMatch of paramMatches) {\r\n    //Get param name from Function/Sub declaration\r\n    let name = paramMatch.groups?.name;\r\n    if (!name) continue;\r\n\r\n    //Get param data from comment\r\n    if (!paramData[name.toLowerCase()]?.length) continue;\r\n    const commentData = paramData[name.toLowerCase()][0].data;\r\n\r\n    /**\r\n     * Parse param type, prioritise comment type, then code type, then default to Variant\r\n     * description is always the comment description\r\n     * referenceType is from the function/sub declaration, or ByRef if unspecified\r\n     * paramArray is from the function/sub declaration, or false if unspecified\r\n     * optional is from the function/sub declaration, or false if unspecified\r\n     * If param is optional, and no default value is provided, set default value to null\r\n     */\r\n    let paramType: string =\r\n      commentData.type ?? paramMatch.groups?.type ?? \"Variant\";\r\n    let paramDescription: string = commentData.description ?? \"\";\r\n    let paramReferenceType: string =\r\n      paramMatch.groups?.referenceType ?? \"ByRef\";\r\n    let paramIsParamArray: boolean = !!paramMatch.groups?.paramArray;\r\n    let paramIsArray: boolean = !!paramMatch.groups?.isArray;\r\n    let paramIsOptional: boolean = !!paramMatch.groups?.optional;\r\n    let paramDefaultValue: string | null = !!paramMatch.groups?.optional\r\n      ? paramMatch.groups.defaultValue ?? null\r\n      : null;\r\n\r\n    //Special cases\r\n    //If param is an array, and no type is provided in the commentary, assume it's an array of `paramType`\r\n    if (paramIsArray && !!commentData.type) paramType = `Array<${paramType}>`;\r\n\r\n    //Add param to store\r\n    paramStore.push({\r\n      tag: \"param\",\r\n      data: {\r\n        name: name.trim(),\r\n        type: paramType.trim(),\r\n        description: paramDescription.trim(),\r\n        referenceType: paramReferenceType,\r\n        paramArray: paramIsParamArray,\r\n        optional: paramIsOptional,\r\n        defaultValue: paramDefaultValue,\r\n      },\r\n    });\r\n  }\r\n\r\n  return paramStore;\r\n}\r\n\r\nfunction parseModuleOrClass(\r\n  content: string,\r\n  fileName: string\r\n): IModule | IClass {\r\n  let isClass = /^VERSION 1.0 CLASS/.test(content);\r\n\r\n  //remove all conditional compilation from module\r\n  let regexConditionalCompilation = /#if.+then\\s+((.|\\s)+?)#end if/gi;\r\n  while (regexConditionalCompilation.test(content)) {\r\n    content = content.replace(regexConditionalCompilation, \"$1\");\r\n  }\r\n\r\n  //Initialise module\r\n  const moduleNameFinder = /Attribute VB_Name = \"(?<name>[^\"]+)\"/i;\r\n  const moduleName =\r\n    moduleNameFinder.exec(content)?.groups?.name ?? fileName.split(\".\")[0];\r\n  log(`Parsing module \"${moduleName}\"`);\r\n  const moduleDocsFinder = /'@module.*\\r?\\n('.*\\r?\\n)*/i;\r\n  const moduleDocsString = moduleDocsFinder.exec(content)?.groups?.[0];\r\n  const moduleDocs = parseComment(moduleDocsString);\r\n  const moduleDocsByTag = groupBy(moduleDocs, (c) => c.tag);\r\n  const moduleTODOs = Array.from(content.matchAll(/'TODO: (.*)/gi)).map(\r\n    (m) => m[1]\r\n  );\r\n\r\n  const defaultMemberFinder = /Attribute (\\w+).VB_(Var)?UserMemId += +0/i;\r\n  const defaultMember = defaultMemberFinder.exec(content)?.groups?.[1];\r\n  const implementsFinder = /^implements +(?<interface>\\w+)/gi;\r\n  const _implements = Array.from(content.matchAll(implementsFinder)).map(\r\n    (m) => m.groups?.interface\r\n  );\r\n\r\n  //Find documentation. This usually looks like a comment block, followed by a method/property/event declaration.\r\n  const memberDocsFinder =\r\n    /(?<comments>(?:\\'.*\\r?\\n)*)(?<!' *)Public (?:(?<type>Function|Sub|Event|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>[^)]*)\\)(?: as (?<retType>\\w+))?/gim;\r\n  const memberMatches = Array.from(content.matchAll(memberDocsFinder));\r\n\r\n  //populate members\r\n  let constructors: IConstructor[] = [];\r\n  let events: IEvent[] = [];\r\n  let properties: IProperty[] = [];\r\n  let methods: IMethod[] = [];\r\n  let membersByName = groupBy(memberMatches, (m: any) =>\r\n    m.groups?.name.toLowerCase()\r\n  ); //used for property access\r\n  let memberAlreadyProcessed: { [key: string]: boolean } = {};\r\n  memberMatches.forEach((match) => {\r\n    let sComment = match.groups?.comments;\r\n    let sType: \"function\" | \"sub\" | \"event\" | \"property\" =\r\n      match.groups?.type.toLowerCase() as\r\n        | \"function\"\r\n        | \"sub\"\r\n        | \"event\"\r\n        | \"property\";\r\n    let sName = match.groups?.name;\r\n    let sParams = match.groups?.params ?? \"\";\r\n    let sRetType = match.groups?.retType ?? \"Void\";\r\n\r\n    //Mark member as processed to ensure it doesn't get processed again, especially important for properties as each `get`, `let` and `set` are declared as different rows.\r\n    if (memberAlreadyProcessed[sName.toLowerCase()]) return;\r\n    memberAlreadyProcessed[sName.toLowerCase()] = true;\r\n\r\n    //Determine property access\r\n    let access: \"ReadOnly\" | \"WriteOnly\" | \"ReadWrite\";\r\n    if (sType === \"property\") {\r\n      let accessTypes = membersByName[sName.toLowerCase()].map((match) =>\r\n        match.groups?.access.toLowerCase()\r\n      );\r\n      let readAccess = accessTypes.includes(\"get\");\r\n      let writeAccess =\r\n        accessTypes.includes(\"let\") || accessTypes.includes(\"set\");\r\n      if (readAccess && writeAccess) {\r\n        access = \"ReadWrite\";\r\n      } else if (readAccess) {\r\n        access = \"ReadOnly\";\r\n      } else if (writeAccess) {\r\n        access = \"WriteOnly\";\r\n      }\r\n    }\r\n\r\n    let commentData: ICommentStore;\r\n    if (sComment.length > 0) {\r\n      commentData = parseComment(sComment);\r\n    }\r\n    let commentDataByTag = groupBy(commentData, (c) => c.tag);\r\n\r\n    let params: IParam[] = parseParams(\r\n      sParams,\r\n      commentDataByTag[\"param\"] as IDataParam[]\r\n    ).map((param: IDataParam) => {\r\n      return {\r\n        name: param.data.name,\r\n        type: param.data.type,\r\n        description: param.data?.description ?? \"\",\r\n        optional: param.data?.optional ?? false,\r\n        defaultValue: param.data?.defaultValue ?? null,\r\n        paramArray: param.data?.paramArray ?? false,\r\n        referenceType:\r\n          (param.data?.referenceType as \"ByRef\" | \"ByVal\" | null) ?? \"ByRef\",\r\n      };\r\n    });\r\n\r\n    switch (sType) {\r\n      case \"sub\":\r\n      case \"function\":\r\n        let arrToPushTo: IMethod[] | IConstructor[] = !!commentDataByTag[\r\n          \"constructor\"\r\n        ]?.length\r\n          ? constructors\r\n          : methods;\r\n\r\n        let func: IConstructor | IMethod = {\r\n          name: sName,\r\n          description:\r\n            (commentDataByTag[\"description\"]?.[0] as IDataDescription)?.data ??\r\n            \"\",\r\n          remarks:\r\n            commentDataByTag[\"remark\"]?.map((c: IDataRemark) => c.data) ?? [],\r\n          examples:\r\n            commentDataByTag[\"example\"]?.map((c: IDataExample) => c.data) ?? [],\r\n          params,\r\n          returns:\r\n            sType === \"sub\"\r\n              ? null\r\n              : {\r\n                  type:\r\n                    (commentDataByTag[\"returns\"]?.[0] as IDataReturn)?.data\r\n                      .type ?? sRetType,\r\n                  description:\r\n                    (commentDataByTag[\"returns\"]?.[0] as IDataReturn)?.data\r\n                      .description ?? \"\",\r\n                },\r\n          deprecation: {\r\n            status: !!commentDataByTag[\"deprecated\"]?.length,\r\n            message:\r\n              (commentDataByTag[\"deprecated\"]?.[0] as IDataDeprecated)?.data ??\r\n              \"\",\r\n          },\r\n          isDefaultMember: defaultMember === sName,\r\n          devNotes:\r\n            commentDataByTag[\"devNote\"]?.map((c: IDataDevNote) => c.data) ?? [],\r\n          todos: commentDataByTag[\"todo\"]?.map((c: IDataTODO) => c.data) ?? [],\r\n          isProtected: !!commentDataByTag[\"protected\"]?.length,\r\n          throws:\r\n            commentDataByTag[\"throws\"]?.map((c: IDataThrows) => c.data) ?? [],\r\n          requires:\r\n            commentDataByTag[\"requires\"]?.map((c: IDataRequires) => c.data) ??\r\n            [],\r\n          isStatic: !!commentDataByTag[\"static\"]?.length,\r\n        };\r\n        arrToPushTo.push(func);\r\n        break;\r\n      case \"property\":\r\n        let prop: IProperty = {\r\n          name: sName,\r\n          access,\r\n          description:\r\n            (commentDataByTag[\"description\"]?.[0] as IDataDescription)?.data ??\r\n            \"\",\r\n          remarks:\r\n            commentDataByTag[\"remark\"]?.map((c: IDataRemark) => c.data) ?? [],\r\n          examples:\r\n            commentDataByTag[\"example\"]?.map((c: IDataExample) => c.data) ?? [],\r\n          params,\r\n          returns: {\r\n            type:\r\n              (commentDataByTag[\"returns\"]?.[0] as IDataReturn)?.data.type ??\r\n              sRetType,\r\n            description:\r\n              (commentDataByTag[\"returns\"]?.[0] as IDataReturn)?.data\r\n                .description ?? \"\",\r\n          },\r\n          deprecation: {\r\n            status: !!commentDataByTag[\"deprecated\"]?.length,\r\n            message:\r\n              (commentDataByTag[\"deprecated\"]?.[0] as IDataDeprecated)?.data ??\r\n              \"\",\r\n          },\r\n          isDefaultMember: defaultMember === sName,\r\n          devNotes:\r\n            commentDataByTag[\"devNote\"]?.map((c: IDataDevNote) => c.data) ?? [],\r\n          todos: commentDataByTag[\"todo\"]?.map((c: IDataTODO) => c.data) ?? [],\r\n          isProtected: !!commentDataByTag[\"protected\"]?.length,\r\n          throws:\r\n            commentDataByTag[\"throws\"]?.map((c: IDataThrows) => c.data) ?? [],\r\n          requires:\r\n            commentDataByTag[\"requires\"]?.map((c: IDataRequires) => c.data) ??\r\n            [],\r\n          isStatic: !!commentDataByTag[\"static\"]?.length,\r\n        };\r\n        properties.push(prop);\r\n        break;\r\n      case \"event\":\r\n        events.push({\r\n          name: sName,\r\n          description:\r\n            (commentDataByTag[\"returns\"]?.[0] as IDataReturn)?.data\r\n              .description ?? \"\",\r\n          remarks:\r\n            commentDataByTag[\"remark\"]?.map((c: IDataRemark) => c.data) ?? [],\r\n          examples:\r\n            commentDataByTag[\"example\"]?.map((c: IDataExample) => c.data) ?? [],\r\n          params,\r\n          devNotes:\r\n            commentDataByTag[\"devNote\"]?.map((c: IDataDevNote) => c.data) ?? [],\r\n          todos: commentDataByTag[\"todo\"]?.map((c: IDataTODO) => c.data) ?? [],\r\n        });\r\n        break;\r\n    }\r\n  });\r\n\r\n  //Build base module\r\n  let mod: IModule = {\r\n    name: moduleName,\r\n    fileName,\r\n    methods,\r\n    properties,\r\n    description:\r\n      (moduleDocsByTag[\"description\"]?.[0] as IDataDescription)?.data ?? \"\",\r\n    remarks: moduleDocsByTag[\"remark\"]?.map((c: IDataRemark) => c.data) ?? [],\r\n    examples:\r\n      moduleDocsByTag[\"example\"]?.map((c: IDataExample) => c.data) ?? [],\r\n    devNotes:\r\n      moduleDocsByTag[\"devNote\"]?.map((c: IDataDevNote) => c.data) ?? [],\r\n    todos: moduleTODOs,\r\n    requires:\r\n      moduleDocsByTag[\"requires\"]?.map((c: IDataRequires) => c.data) ?? [],\r\n  };\r\n\r\n  //If it's a class then add additional members\r\n  if (isClass) {\r\n    return {\r\n      ...mod,\r\n      constructors,\r\n      events,\r\n      implements: _implements,\r\n    };\r\n  } else {\r\n    return mod;\r\n  }\r\n}\r\n\r\nimport { throws } from \"assert\";\r\nimport * as fs from \"fs\";\r\nfunction main() {\r\n  //Find all files in ../../src directory\r\n  let files = fs.readdirSync(__dirname + \"/../../src\");\r\n  files = files.filter((f) =>\r\n    fs.lstatSync(__dirname + \"/../../src/\" + f).isFile()\r\n  );\r\n\r\n  //Scan files for public methods and properties, dump to docs array\r\n  let docs: IDocs = files.map((file) => {\r\n    return parseModuleOrClass(\r\n      fs.readFileSync(__dirname + \"/../../src/\" + file, \"utf8\"),\r\n      file\r\n    );\r\n  });\r\n\r\n  //Dump docs array to docs.json\r\n  fs.writeFileSync(\r\n    __dirname + \"/../../docs.json\",\r\n    JSON.stringify(docs, null, 2),\r\n    \"utf8\"\r\n  );\r\n}\r\n\r\nmain();\r\n"],
  "mappings": "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",
  "names": ["match"]
}
