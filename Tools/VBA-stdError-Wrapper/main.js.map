{
  "version": 3,
  "sources": ["main.ts"],
  "sourcesContent": ["//Process description:\r\n\r\n/* \r\n 1. Read all files in ../../src directory\r\n 2. Append a function to the end of each files as follows:\r\n\r\n```vb\r\nPrivate Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = \"\", Optional ByVal description as string = \"\")\r\n  Call stdError.Raise(description)\r\nEnd Sub\r\n```\r\n3. Replace all calls to `Err.Raise` to calls to `Err_Raise`\r\n4. Replace all calls to `On Error GoTo 0` with `On Error GoTo stdErrorWrapper_ErrorOccurred`\r\n5. Perform the following mapping:\r\n\r\n```vb\r\nPublic Function MyMethod(ByVal param1 as type1, ByVal param2 as type2, ...) as returnType\r\n  ...\r\nEnd Function\r\n```\r\n\r\nto\r\n\r\n```vb\r\nPublic Function MyMethod(ByVal param1 as type1, ByVal param2 as type2, ...) as returnType\r\n  With stdError.getSentry(\"ModuleName#MMyethod (Access)\", \"param1\", param1, \"param2\", param2, ...)\r\n  On Error GoTo stdErrorWrapper_ErrorOccurred\r\n    ...\r\n  stdErrorWrapper_ErrorOccurred:\r\n    Call Err_Raise(Err.Number, Err.Source, Err.Description)\r\n  End With\r\nEnd Function\r\n```\r\n\r\n6. Save and overwrite the files\r\n\r\nThis will be run on a every commit, and will publish to the `stdErrorWrapped` branch.\r\n\r\nWatchouts:\r\n---------------------------------------\r\n1. Conditional compilation directives should be preserved\r\n\r\n```vb\r\n#If VBA7 Then\r\n  Public Function MyMethod(...)\r\n#Else\r\n  Public Function MyMethod(...)\r\n#End If\r\n  ...\r\nEnd Function\r\n```\r\n----------------------------------------\r\n\r\n*/\r\n\r\n\r\ntype IUDTInfo = {\r\n  name: string\r\n}\r\ntype IParameter = {\r\n  name: string;\r\n  type: string;\r\n  referenceType: string;\r\n  isOptional: boolean;\r\n  defaultValue?: any;\r\n  isParamArray: boolean;\r\n  isArray: boolean;\r\n  isUDTParamType: boolean;\r\n};\r\n\r\n/**\r\n * obtain information about the parameters declared by the function, subroutine or property\r\n * @param params a parameter string e.g. ``ByVal sClassName As String, ByVal x As Long, ByVal y As Long, ByVal width As Long, ByVal height As Long, Optional ByVal sCaption As String = vbNullString, Optional ByVal dwStyle As Long = WS_POPUP`\r\n * @param udtInfo an array of IUDTInfo objects which contain information about user defined types defined in the class/moudule\r\n * @returns an array of IParameter objects which contain information about the parameters\r\n */\r\nfunction parseParameters(params: string, udtInfo: IUDTInfo[]): IParameter[] {\r\n  let paramExtractor = /(?<optional>optional\\s+)?(?:(?<referenceType>byval|byref)\\s+)?(?:(?<paramarray>paramarray)\\s+)?(?<name>\\w+)(?<isArray>\\(\\))?(?:\\s+as\\s+(?<type>[^, )]+))?(?:\\s*=\\s*(?<defaultValue>.+))?/i\r\n  let aParams = params.split(\",\").map((param)=>param.trim().match(paramExtractor)).map((match)=>match?.groups)\r\n  if (!aParams || aParams.length === 0) return [];\r\n\r\n  return aParams.map((param) => {\r\n    if (!param) return null;\r\n    const isUDTParamType = udtInfo.some(udt => udt.name.toLowerCase() === param.type.toLowerCase());\r\n    return {\r\n      name: param.name,\r\n      type: param.type || \"\",\r\n      referenceType: param.referenceType || \"\",\r\n      isOptional: !!param.optional,\r\n      defaultValue: param.defaultValue ? param.defaultValue.trim() : undefined,\r\n      isParamArray: !!param.paramarray,\r\n      isArray: !!param.isArray,\r\n      isUDTParamType\r\n    };\r\n  }).filter(param => param !== null);\r\n} \r\n\r\nimport { throws } from \"assert\";\r\nimport * as fs from \"fs\";\r\nfunction main() {\r\n  //Find all files in ../../src directory\r\n  let files = fs.readdirSync(__dirname + \"/../../src\");\r\n  files = files.filter((f) =>\r\n    fs.lstatSync(__dirname + \"/../../src/\" + f).isFile()\r\n  );\r\n\r\n  //Loop through each file\r\n  for (const file of files) {\r\n    //Read the file\r\n    let content = fs.readFileSync(__dirname + \"/../../src/\" + file, \"utf8\");\r\n\r\n    //Find the module name\r\n    const moduleNameFinder = /Attribute VB_Name = \"(?<name>[^\"]+)\"/i;\r\n    const moduleName =\r\n      moduleNameFinder.exec(content)?.groups?.name ?? file.split(\".\")[0];\r\n\r\n    //Append the function to the end of the file\r\n    content += `\\n\\n\r\nPrivate Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = \"\", Optional ByVal description as string = \"\")\r\n  Call stdError.Raise(description)\r\nEnd Sub\r\n`;\r\n\r\n    //Replace all calls to `Err.Raise` to calls to `Err_Raise`\r\n    content = content.replace(/Err\\.Raise/g, \"Err_Raise\");\r\n    content = content.replace(/On Error GoTo 0/g, \"On Error GoTo stdErrorWrapper_ErrorOccurred\");\r\n\r\n    //Loop through each public function\r\n    const functionFinder = /(?<header>(?<!')(?:Public|Private|Friend) (?:(?<type>Function|Sub|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>(?:\\(\\)|[^)])*)\\)(?: as (?<retType>(?:\\w+\\.)?\\w+))?)(?<body>(?:.|\\s)+?)\\b(?<footer>End\\s+(?:Function|Sub|Property))/gim\r\n    content = content.replace(functionFinder, (match: string, header: string, type: string, access: string, name: string, params: string, retType: string, body: string, footer: string, offset: number, haystack: string, groups: any): string => {\r\n      //Check if the body has another declare in it followed by a `#End If` declaration.\r\n      const conditionalCompilation = /(?<!')(?:Public|Private|Friend) (?:(?<type>Function|Sub|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>(?:\\(\\)|[^)])*)\\)(?: as (?<retType>(?:\\w+\\.)?\\w+))?(?:.|\\s)+?#End If/gim\r\n      \r\n      //Redefine body and header to include / exclude the conditional compilation directives as needed\r\n      const conditionalCompilationMatch = conditionalCompilation.exec(body);\r\n      if (!!conditionalCompilationMatch) {\r\n        header = header + body.substring(0,conditionalCompilationMatch.index + conditionalCompilationMatch[0].length)\r\n        body = body.substring(conditionalCompilationMatch.index + conditionalCompilationMatch[0].length)\r\n      }\r\n\r\n      //Get the callstack name\r\n      if(!access) access = \" (\" + access + \")\"\r\n      let callstackName = moduleName + \"#\" + name + access;\r\n\r\n      //Parse the parameters\r\n      const udtInfo: IUDTInfo[] = [];\r\n      const paramsInfo = parseParameters(params, udtInfo);\r\n\r\n      //TODO: Handle UDTs\r\n      //TODO: Handle ParamArray\r\n      //TODO: Handle Arrays\r\n      const paramsString = paramsInfo.filter(p => !p.isUDTParamType && !p.isParamArray && !p.isArray).map(p => `\"${p.name}\", ${p.name}`).join(\", \");\r\n\r\n      const injectorHeader = [\r\n        `  With stdError.getSentry(\"${callstackName}\", ${paramsString})`,\r\n        \"    On Error GoTo stdErrorWrapper_ErrorOccurred\"\r\n      ].join(\"\\r\\n\");\r\n\r\n      const injectorFooter = [\r\n        \"  stdErrorWrapper_ErrorOccurred:\",\r\n        \"    Call Err_Raise(Err.Number, Err.Source, Err.Description)\",\r\n        \"  End With\"\r\n      ].join(\"\\r\\n\");\r\n\r\n      //Indent all lines of body by 4 spaces\r\n      body = body.split(\"\\n\").map(line => \"    \" + line).join(\"\\n\");\r\n\r\n      return `${header}\\r\\n${injectorHeader}\\r\\n${body}\\r\\n${injectorFooter}\\r\\n${footer}`;\r\n    })\r\n\r\n    //Save the file\r\n    fs.writeFileSync(__dirname + \"/../../src/\" + file, content, \"utf8\");\r\n  }\r\n}\r\n\r\nmain();\r\n"],
  "mappings": "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",
  "names": []
}
