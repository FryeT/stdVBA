{
  "version": 3,
  "sources": ["main.ts"],
  "sourcesContent": ["//Process description:\n\n/* \n 1. Read all files in ../../src directory\n 2. Append a function to the end of each files as follows:\n\n```vb\nPrivate Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = \"\", Optional ByVal description as string = \"\")\n  Call stdError.Raise(description)\nEnd Sub\n```\n3. Replace all calls to `Err.Raise` to calls to `Err_Raise`\n4. Replace all calls to `On Error GoTo 0` with `On Error GoTo stdErrorWrapper_ErrorOccurred`\n5. Perform the following mapping:\n\n```vb\nPublic Function MyMethod(ByVal param1 as type1, ByVal param2 as type2, ...) as returnType\n  ...\nEnd Function\n```\n\nto\n\n```vb\nPublic Function MyMethod(ByVal param1 as type1, ByVal param2 as type2, ...) as returnType\n  With stdError.getSentry(\"ModuleName#MMyethod (Access)\", \"param1\", param1, \"param2\", param2, ...)\n  On Error GoTo stdErrorWrapper_ErrorOccurred\n    ...\n  stdErrorWrapper_ErrorOccurred:\n    Call Err_Raise(Err.Number, Err.Source, Err.Description)\n  End With\nEnd Function\n```\n\n6. Save and overwrite the files\n\nThis will be run on a every commit, and will publish to the `stdErrorWrapped` branch.\n\nWatchouts:\n---------------------------------------\n1. Conditional compilation directives should be preserved\n\n```vb\n#If VBA7 Then\n  Public Function MyMethod(...)\n#Else\n  Public Function MyMethod(...)\n#End If\n  ...\nEnd Function\n```\n----------------------------------------\n\n*/\n\ntype IUDTInfo = {\n  name: string;\n};\ntype IParameter = {\n  name: string;\n  type: string;\n  referenceType: string;\n  isOptional: boolean;\n  defaultValue?: any;\n  isParamArray: boolean;\n  isArray: boolean;\n  isUDTParamType: boolean;\n};\n\n/**\n * obtain information about the parameters declared by the function, subroutine or property\n * @param params a parameter string e.g. ``ByVal sClassName As String, ByVal x As Long, ByVal y As Long, ByVal width As Long, ByVal height As Long, Optional ByVal sCaption As String = vbNullString, Optional ByVal dwStyle As Long = WS_POPUP`\n * @param udtInfo an array of IUDTInfo objects which contain information about user defined types defined in the class/moudule\n * @returns an array of IParameter objects which contain information about the parameters\n */\nfunction parseParameters(params: string, udtInfo: IUDTInfo[]): IParameter[] {\n  let paramExtractor =\n    /(?<optional>optional\\s+)?(?:(?<referenceType>byval|byref)\\s+)?(?:(?<paramarray>paramarray)\\s+)?(?<name>\\w+)(?<isArray>\\(\\))?(?:\\s+as\\s+(?<type>[^, )]+))?(?:\\s*=\\s*(?<defaultValue>.+))?/i;\n  let aParams = params\n    .split(\",\")\n    .map((param) => param.trim().match(paramExtractor))\n    .map((match) => match?.groups);\n  if (!aParams || aParams.length === 0) return [];\n\n  return aParams\n    .map((param) => {\n      if (!param) return null;\n      const isUDTParamType = udtInfo.some(\n        (udt) => udt.name.toLowerCase() === param.type?.toLowerCase()\n      );\n      return {\n        name: param.name,\n        type: param.type || \"\",\n        referenceType: param.referenceType || \"\",\n        isOptional: !!param.optional,\n        defaultValue: param.defaultValue\n          ? param.defaultValue.trim()\n          : undefined,\n        isParamArray: !!param.paramarray,\n        isArray: !!param.isArray,\n        isUDTParamType,\n      };\n    })\n    .filter((param) => param !== null);\n}\n\nimport { throws } from \"assert\";\nimport * as fs from \"fs\";\nfunction main() {\n  //Find all files in ../../src directory\n  let files = fs.readdirSync(__dirname + \"/../../src\");\n  files = files.filter((f) =>\n    fs.lstatSync(__dirname + \"/../../src/\" + f).isFile()\n  );\n\n  //Loop through each file\n  for (const file of files) {\n    //Read the file\n    let content = fs.readFileSync(__dirname + \"/../../src/\" + file, \"utf8\");\n\n    //Find the module name\n    const moduleNameFinder = /Attribute VB_Name = \"(?<name>[^\"]+)\"/i;\n    const moduleName =\n      moduleNameFinder.exec(content)?.groups?.name ?? file.split(\".\")[0];\n\n    //Replace all calls to `Err.Raise` to calls to `Err_Raise`\n    content = content.replace(/Err\\.Raise/g, \"Err_Raise\");\n    content = content.replace(\n      /On Error GoTo 0/g,\n      \"On Error GoTo stdErrorWrapper_ErrorOccurred\"\n    );\n\n    //Get all UDTs defined in the file\n    const udtFinder = /(?<!').*\\bType\\s+(?<name>\\w+)/gim;\n    const udtInfo: IUDTInfo[] = Array.from(content.matchAll(udtFinder)).map(\n      (match) => {\n        return {\n          name: match.groups?.name || \"\",\n        };\n      }\n    );\n\n    //Loop through each public function\n    const functionFinder =\n      /^[ \\t]*(?<header>(?:Public|Private|Friend) (?:(?<type>Function|Sub|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>(?:\\(\\)|[^)])*)\\)(?: as (?<retType>(?:\\w+\\.)?\\w+(?:\\(\\))?))?)(?<body>(?:.|\\s)+?)\\b(?<footer>End\\s+(?:Function|Sub|Property))/gim;\n    content = content.replace(\n      functionFinder,\n      (\n        match: string,\n        header: string,\n        type: string,\n        access: string,\n        name: string,\n        params: string,\n        retType: string,\n        body: string,\n        footer: string,\n        offset: number,\n        haystack: string,\n        groups: any\n      ): string => {\n        //Check if the body has another declare in it followed by a `#End If` declaration.\n        const conditionalCompilation =\n          /(?<!')(?:Public|Private|Friend) (?:(?<type>Function|Sub|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>(?:\\(\\)|[^)])*)\\)(?: as (?<retType>(?:\\w+\\.)?\\w+))?(?:.|\\s)+?#End If/gim;\n\n        //Redefine body and header to include / exclude the conditional compilation directives as needed\n        const conditionalCompilationMatch = conditionalCompilation.exec(body);\n        if (!!conditionalCompilationMatch) {\n          header =\n            header +\n            body.substring(\n              0,\n              conditionalCompilationMatch.index +\n                conditionalCompilationMatch[0].length\n            );\n          body = body.substring(\n            conditionalCompilationMatch.index +\n              conditionalCompilationMatch[0].length\n          );\n        }\n\n        //Get the callstack name\n        let callstackName =\n          moduleName + \"#\" + name + (!!access ? \"[\" + access + \"]\" : \"\");\n\n        //Parse the parameters\n        const paramsInfo = parseParameters(params, udtInfo);\n\n        //TODO: Handle UDTs\n        //TODO: Handle ParamArray\n        //TODO: Handle Arrays\n        const finalParams = paramsInfo\n          .filter((p) => !p.isUDTParamType && !p.isParamArray && !p.isArray)\n          .map((p) => `\"${p.name}\", ${p.name}`);\n        const paramsString =\n          (finalParams.length > 0 ? \", \" : \"\") + finalParams.join(\", \");\n\n        const injectorHeader = [\n          `  With stdError.getSentry(\"${callstackName}\"${paramsString})`,\n          \"    On Error GoTo stdErrorWrapper_ErrorOccurred\",\n        ].join(\"\\r\\n\");\n\n        const injectorFooter = [\n          \"    Exit \" + type,\n          \"    stdErrorWrapper_ErrorOccurred:\",\n          \"      Call Err_Raise(Err.Number, Err.Source, Err.Description)\",\n          \"  End With\",\n        ].join(\"\\r\\n\");\n\n        //Indent all lines of body by 4 spaces\n        body = body\n          .split(\"\\n\")\n          .map((line) => \"    \" + line)\n          .join(\"\\n\");\n\n        return `${header}\\r\\n${injectorHeader}\\r\\n${body}\\r\\n${injectorFooter}\\r\\n${footer}`;\n      }\n    );\n\n    //Append the function to the end of the file\n    content += `\\n\\n\nPrivate Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = \"\", Optional ByVal description as string = \"\")\n  Call stdError.Raise(description)\nEnd Sub\n`;\n\n    //Save the file\n    fs.writeFileSync(__dirname + \"/../../src/\" + file, content, \"utf8\");\n  }\n}\n\nmain();\n"],
  "mappings": "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",
  "names": []
}
