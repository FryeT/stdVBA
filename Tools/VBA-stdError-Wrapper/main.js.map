{
  "version": 3,
  "sources": ["main.ts"],
  "sourcesContent": ["//Process description:\n\n/* \n 1. Read all files in ../../src directory\n 2. Append a function to the end of each files as follows:\n\n```vb\nPrivate Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = \"\", Optional ByVal description as string = \"\")\n  Call stdError.Raise(description)\nEnd Sub\n```\n3. Replace all calls to `Err.Raise` to calls to `Err_Raise`\n4. Replace all calls to `On Error GoTo 0` with `On Error GoTo stdErrorWrapper_ErrorOccurred`\n5. Perform the following mapping:\n\n```vb\nPublic Function MyMethod(ByVal param1 as type1, ByVal param2 as type2, ...) as returnType\n  ...\nEnd Function\n```\n\nto\n\n```vb\nPublic Function MyMethod(ByVal param1 as type1, ByVal param2 as type2, ...) as returnType\n  With stdError.getSentry(\"ModuleName#MMyethod (Access)\", \"param1\", param1, \"param2\", param2, ...)\n  On Error GoTo stdErrorWrapper_ErrorOccurred\n    ...\n  stdErrorWrapper_ErrorOccurred:\n    Call Err_Raise(Err.Number, Err.Source, Err.Description)\n  End With\nEnd Function\n```\n\n6. Save and overwrite the files\n\nThis will be run on a every commit, and will publish to the `stdErrorWrapped` branch.\n\nWatchouts:\n---------------------------------------\n1. Conditional compilation directives should be preserved\n\n```vb\n#If VBA7 Then\n  Public Function MyMethod(...)\n#Else\n  Public Function MyMethod(...)\n#End If\n  ...\nEnd Function\n```\n----------------------------------------\n\n*/\n\n\ntype IUDTInfo = {\n  name: string\n}\ntype IParameter = {\n  name: string;\n  type: string;\n  referenceType: string;\n  isOptional: boolean;\n  defaultValue?: any;\n  isParamArray: boolean;\n  isArray: boolean;\n  isUDTParamType: boolean;\n};\n\n/**\n * obtain information about the parameters declared by the function, subroutine or property\n * @param params a parameter string e.g. ``ByVal sClassName As String, ByVal x As Long, ByVal y As Long, ByVal width As Long, ByVal height As Long, Optional ByVal sCaption As String = vbNullString, Optional ByVal dwStyle As Long = WS_POPUP`\n * @param udtInfo an array of IUDTInfo objects which contain information about user defined types defined in the class/moudule\n * @returns an array of IParameter objects which contain information about the parameters\n */\nfunction parseParameters(params: string, udtInfo: IUDTInfo[]): IParameter[] {\n  let paramExtractor = /(?<optional>optional\\s+)?(?:(?<referenceType>byval|byref)\\s+)?(?:(?<paramarray>paramarray)\\s+)?(?<name>\\w+)(?<isArray>\\(\\))?(?:\\s+as\\s+(?<type>[^, )]+))?(?:\\s*=\\s*(?<defaultValue>.+))?/i\n  let aParams = params.split(\",\").map((param)=>param.trim().match(paramExtractor)).map((match)=>match?.groups)\n  if (!aParams || aParams.length === 0) return [];\n\n  return aParams.map((param) => {\n    if (!param) return null;\n    const isUDTParamType = udtInfo.some(udt => udt.name.toLowerCase() === param.type?.toLowerCase());\n    return {\n      name: param.name,\n      type: param.type || \"\",\n      referenceType: param.referenceType || \"\",\n      isOptional: !!param.optional,\n      defaultValue: param.defaultValue ? param.defaultValue.trim() : undefined,\n      isParamArray: !!param.paramarray,\n      isArray: !!param.isArray,\n      isUDTParamType\n    };\n  }).filter(param => param !== null);\n} \n\nimport { throws } from \"assert\";\nimport * as fs from \"fs\";\nfunction main() {\n  //Find all files in ../../src directory\n  let files = fs.readdirSync(__dirname + \"/../../src\");\n  files = files.filter((f) =>\n    fs.lstatSync(__dirname + \"/../../src/\" + f).isFile()\n  );\n\n  //Loop through each file\n  for (const file of files) {\n    //Read the file\n    let content = fs.readFileSync(__dirname + \"/../../src/\" + file, \"utf8\");\n\n    //Find the module name\n    const moduleNameFinder = /Attribute VB_Name = \"(?<name>[^\"]+)\"/i;\n    const moduleName =\n      moduleNameFinder.exec(content)?.groups?.name ?? file.split(\".\")[0];\n\n    //Replace all calls to `Err.Raise` to calls to `Err_Raise`\n    content = content.replace(/Err\\.Raise/g, \"Err_Raise\");\n    content = content.replace(/On Error GoTo 0/g, \"On Error GoTo stdErrorWrapper_ErrorOccurred\");\n\n    //Get all UDTs defined in the file\n    const udtFinder = /(?<!').*\\bType\\s+(?<name>\\w+)/gim;\n    const udtInfo: IUDTInfo[] = Array.from(content.matchAll(udtFinder)).map((match) => {\n      return {\n        name: match.groups?.name || \"\"\n      };\n    });\n\n    //Loop through each public function\n    const functionFinder = /(?<header>(?<!')(?:Public|Private|Friend) (?:(?<type>Function|Sub|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>(?:\\(\\)|[^)])*)\\)(?: as (?<retType>(?:\\w+\\.)?\\w+))?)(?<body>(?:.|\\s)+?)\\b(?<footer>End\\s+(?:Function|Sub|Property))/gim\n    content = content.replace(functionFinder, (match: string, header: string, type: string, access: string, name: string, params: string, retType: string, body: string, footer: string, offset: number, haystack: string, groups: any): string => {\n      //Check if the body has another declare in it followed by a `#End If` declaration.\n      const conditionalCompilation = /(?<!')(?:Public|Private|Friend) (?:(?<type>Function|Sub|Property) ?(?<access>Get|Let|Set)?) (?<name>\\w+)\\((?<params>(?:\\(\\)|[^)])*)\\)(?: as (?<retType>(?:\\w+\\.)?\\w+))?(?:.|\\s)+?#End If/gim\n      \n      //Redefine body and header to include / exclude the conditional compilation directives as needed\n      const conditionalCompilationMatch = conditionalCompilation.exec(body);\n      if (!!conditionalCompilationMatch) {\n        header = header + body.substring(0,conditionalCompilationMatch.index + conditionalCompilationMatch[0].length)\n        body = body.substring(conditionalCompilationMatch.index + conditionalCompilationMatch[0].length)\n      }\n\n      //Get the callstack name\n      let callstackName = moduleName + \"#\" + name + ((!!access) ? \"[\" + access + \"]\" : \"\");\n\n      //Parse the parameters\n      const paramsInfo = parseParameters(params, udtInfo);\n\n      //TODO: Handle UDTs\n      //TODO: Handle ParamArray\n      //TODO: Handle Arrays\n      const paramsString = paramsInfo.filter(p => !p.isUDTParamType && !p.isParamArray && !p.isArray).map(p => `\"${p.name}\", ${p.name}`).join(\", \");\n\n      const injectorHeader = [\n        `  With stdError.getSentry(\"${callstackName}\", ${paramsString})`,\n        \"    On Error GoTo stdErrorWrapper_ErrorOccurred\"\n      ].join(\"\\r\\n\");\n\n      const injectorFooter = [\n        \"    Exit \" + type,\n        \"    stdErrorWrapper_ErrorOccurred:\",\n        \"      Call Err_Raise(Err.Number, Err.Source, Err.Description)\",\n        \"  End With\"\n      ].join(\"\\r\\n\");\n\n      //Indent all lines of body by 4 spaces\n      body = body.split(\"\\n\").map(line => \"    \" + line).join(\"\\n\");\n\n      return `${header}\\r\\n${injectorHeader}\\r\\n${body}\\r\\n${injectorFooter}\\r\\n${footer}`;\n    })\n\n    //Append the function to the end of the file\n    content += `\\n\\n\nPrivate Sub Err_Raise(ByVal number as Long, Optional ByVal source as string = \"\", Optional ByVal description as string = \"\")\n  Call stdError.Raise(description)\nEnd Sub\n`;\n\n    //Save the file\n    fs.writeFileSync(__dirname + \"/../../src/\" + file, content, \"utf8\");\n  }\n}\n\nmain();\n"],
  "mappings": "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",
  "names": []
}
